declare function prev(v: number): number;
declare function next(v: number): number;
/**
 * @alias module:interval-arithmetic/round-math
 */
declare const round: {
    /**
     * Computes the previous IEEE floating point representation of `v`
     * @example
     * Interval.round.safePrev(1)          // 0.9999999999999999
     * Interval.round.safePrev(3)          // 2.9999999999999996
     * Interval.round.safePrev(Infinity)   // Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safePrev: typeof prev;
    /**
     * Computes the next IEEE floating point representation of `v`
     * @example
     * Interval.round.safeNext(1)          // 1.0000000000000002
     * Interval.round.safeNext(3)          // 3.0000000000000004
     * Interval.round.safeNext(-Infinity)  // -Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safeNext: typeof next;
    prev(x: number): number;
    next(x: number): number;
    addLo(x: number, y: number): number;
    addHi(x: number, y: number): number;
    subLo(x: number, y: number): number;
    subHi(x: number, y: number): number;
    mulLo(x: number, y: number): number;
    mulHi(x: number, y: number): number;
    divLo(x: number, y: number): number;
    divHi(x: number, y: number): number;
    intLo(x: number): number;
    intHi(x: number): number;
    logLo(x: number): number;
    logHi(x: number): number;
    expLo(x: number): number;
    expHi(x: number): number;
    sinLo(x: number): number;
    sinHi(x: number): number;
    cosLo(x: number): number;
    cosHi(x: number): number;
    tanLo(x: number): number;
    tanHi(x: number): number;
    asinLo(x: number): number;
    asinHi(x: number): number;
    acosLo(x: number): number;
    acosHi(x: number): number;
    atanLo(x: number): number;
    atanHi(x: number): number;
    sinhLo(x: number): number;
    sinhHi(x: number): number;
    coshLo(x: number): number;
    coshHi(x: number): number;
    tanhLo(x: number): number;
    tanhHi(x: number): number;
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powLo(x: number, power: number): number;
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powHi(x: number, power: number): number;
    sqrtLo(x: number): number;
    sqrtHi(x: number): number;
    /**
     * Most operations on intervals will cary the rounding error so that the
     * resulting interval correctly represents all the possible values, this feature
     * can be disabled by calling this method allowing a little boost in the
     * performance while operating on intervals
     *
     * @see module:interval-arithmetic/round-math.enable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     * @function
     */
    disable(): void;
    /**
     * Enables IEEE previous/next floating point wrapping of values (enabled by
     * default)
     * @see module:interval-arithmetic/round-math.disable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     *
     * Interval.round.enable()
     * var z = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     * @function
     */
    enable(): void;
};
export default round;
