"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var nextafter_1 = __importDefault(require("nextafter"));
/**
 * @module interval-arithmetic/round-math
 */
function identity(v) {
    return v;
}
function prev(v) {
    if (v === Infinity) {
        return v;
    }
    return nextafter_1.default(v, -Infinity);
}
function next(v) {
    if (v === -Infinity) {
        return v;
    }
    return nextafter_1.default(v, Infinity);
}
function toInteger(x) {
    return x < 0 ? Math.ceil(x) : Math.floor(x);
}
var cache = {
    prev: prev,
    next: next
};
/**
 * @alias module:interval-arithmetic/round-math
 */
var round = {
    /**
     * Computes the previous IEEE floating point representation of `v`
     * @example
     * Interval.round.safePrev(1)          // 0.9999999999999999
     * Interval.round.safePrev(3)          // 2.9999999999999996
     * Interval.round.safePrev(Infinity)   // Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safePrev: prev,
    /**
     * Computes the next IEEE floating point representation of `v`
     * @example
     * Interval.round.safeNext(1)          // 1.0000000000000002
     * Interval.round.safeNext(3)          // 3.0000000000000004
     * Interval.round.safeNext(-Infinity)  // -Infinity
     * @param {number} v
     * @return {number}
     * @function
     */
    safeNext: next,
    prev: function (x) {
        return cache.prev(x);
    },
    next: function (x) {
        return cache.next(x);
    },
    // prettier-ignore
    addLo: function (x, y) { return round.prev(x + y); },
    // prettier-ignore
    addHi: function (x, y) { return round.next(x + y); },
    // prettier-ignore
    subLo: function (x, y) { return round.prev(x - y); },
    // prettier-ignore
    subHi: function (x, y) { return round.next(x - y); },
    // prettier-ignore
    mulLo: function (x, y) { return round.prev(x * y); },
    // prettier-ignore
    mulHi: function (x, y) { return round.next(x * y); },
    // prettier-ignore
    divLo: function (x, y) { return round.prev(x / y); },
    // prettier-ignore
    divHi: function (x, y) { return round.next(x / y); },
    // prettier-ignore
    intLo: function (x) { return toInteger(round.prev(x)); },
    // prettier-ignore
    intHi: function (x) { return toInteger(round.next(x)); },
    // prettier-ignore
    logLo: function (x) { return round.prev(Math.log(x)); },
    // prettier-ignore
    logHi: function (x) { return round.next(Math.log(x)); },
    // prettier-ignore
    expLo: function (x) { return round.prev(Math.exp(x)); },
    // prettier-ignore
    expHi: function (x) { return round.next(Math.exp(x)); },
    // prettier-ignore
    sinLo: function (x) { return round.prev(Math.sin(x)); },
    // prettier-ignore
    sinHi: function (x) { return round.next(Math.sin(x)); },
    // prettier-ignore
    cosLo: function (x) { return round.prev(Math.cos(x)); },
    // prettier-ignore
    cosHi: function (x) { return round.next(Math.cos(x)); },
    // prettier-ignore
    tanLo: function (x) { return round.prev(Math.tan(x)); },
    // prettier-ignore
    tanHi: function (x) { return round.next(Math.tan(x)); },
    // prettier-ignore
    asinLo: function (x) { return round.prev(Math.asin(x)); },
    // prettier-ignore
    asinHi: function (x) { return round.next(Math.asin(x)); },
    // prettier-ignore
    acosLo: function (x) { return round.prev(Math.acos(x)); },
    // prettier-ignore
    acosHi: function (x) { return round.next(Math.acos(x)); },
    // prettier-ignore
    atanLo: function (x) { return round.prev(Math.atan(x)); },
    // prettier-ignore
    atanHi: function (x) { return round.next(Math.atan(x)); },
    // polyfill required for hyperbolic functions
    // prettier-ignore
    sinhLo: function (x) { return round.prev(Math.sinh(x)); },
    // prettier-ignore
    sinhHi: function (x) { return round.next(Math.sinh(x)); },
    // prettier-ignore
    coshLo: function (x) { return round.prev(Math.cosh(x)); },
    // prettier-ignore
    coshHi: function (x) { return round.next(Math.cosh(x)); },
    // prettier-ignore
    tanhLo: function (x) { return round.prev(Math.tanh(x)); },
    // prettier-ignore
    tanhHi: function (x) { return round.next(Math.tanh(x)); },
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powLo: function (x, power) {
        if (power % 1 !== 0) {
            // power has decimals
            return round.prev(Math.pow(x, power));
        }
        var y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
            x = round.mulLo(x, x);
            if ((power & 1) === 1) {
                y = round.mulLo(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    /**
     * @ignore
     * ln(power) exponentiation of x
     * @param {number} x
     * @param {number} power
     * @returns {number}
     */
    powHi: function (x, power) {
        if (power % 1 !== 0) {
            // power has decimals
            return round.next(Math.pow(x, power));
        }
        var y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
            x = round.mulHi(x, x);
            if ((power & 1) === 1) {
                y = round.mulHi(x, y);
            }
            power >>= 1;
        }
        return y;
    },
    // prettier-ignore
    sqrtLo: function (x) { return round.prev(Math.sqrt(x)); },
    // prettier-ignore
    sqrtHi: function (x) { return round.next(Math.sqrt(x)); },
    /**
     * Most operations on intervals will cary the rounding error so that the
     * resulting interval correctly represents all the possible values, this feature
     * can be disabled by calling this method allowing a little boost in the
     * performance while operating on intervals
     *
     * @see module:interval-arithmetic/round-math.enable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     * @function
     */
    disable: function () {
        cache.next = cache.prev = identity;
    },
    /**
     * Enables IEEE previous/next floating point wrapping of values (enabled by
     * default)
     * @see module:interval-arithmetic/round-math.disable
     * @example
     * var x = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     *
     * Interval.round.disable()
     * var y = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * y // equal to {lo: 2, hi: 2}
     *
     * Interval.round.enable()
     * var z = Interval.add(
     *   Interval(1),
     *   Interval(1)
     * )
     * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
     * @function
     */
    enable: function () {
        cache.next = next;
        cache.prev = prev;
    }
};
exports.default = round;
//# sourceMappingURL=round.js.map