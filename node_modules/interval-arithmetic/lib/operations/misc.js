"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var interval_1 = require("../interval");
var round_1 = __importDefault(require("../round"));
var constants_1 = __importDefault(require("../constants"));
var utils = __importStar(require("./utils"));
var arithmetic = __importStar(require("./arithmetic"));
/**
 * @mixin misc
 */
/**
 * Computes e^x where e is the mathematical constant equal to the base of the
 * natural logarithm
 *
 * @example
 * ```typescript
 * Interval.exp(
 *   Interval(-1, 1)
 * )  // Interval(0.3679, 2.7183)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function exp(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return new interval_1.Interval(round_1.default.expLo(x.lo), round_1.default.expHi(x.hi));
}
exports.exp = exp;
/**
 * Computes the natural logarithm of x
 *
 * @example
 * ```typescript
 * Interval.log(
 *   Interval(1, Math.exp(3))
 * )  // Interval(0, 3)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function log(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    var l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : round_1.default.logLo(x.lo);
    return new interval_1.Interval(l, round_1.default.logHi(x.hi));
}
exports.log = log;
/**
 * Alias for {@link log}
 * @function
 */
exports.ln = log;
exports.LOG_EXP_10 = log(new interval_1.Interval(10, 10));
/**
 * Computes the logarithm base 10 of x
 *
 * @example
 * ```typescript
 * Interval.log10(
 *   Interva(1, 1000)
 * )  // Interval(0, 3)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function log10(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return arithmetic.div(log(x), exports.LOG_EXP_10);
}
exports.log10 = log10;
exports.LOG_EXP_2 = log(new interval_1.Interval(2, 2));
/**
 * Computes the logarithm base 2 of x
 *
 * @example
 * ```typescript
 * Interval.log10(
 *   Interva(1, 8)
 * )  // Interval(0, 3)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function log2(x) {
    if (utils.isEmpty(x)) {
        return constants_1.default.EMPTY;
    }
    return arithmetic.div(log(x), exports.LOG_EXP_2);
}
exports.log2 = log2;
/**
 * Computes an interval that has all the values of x and y, note that it may be
 * possible that values that don't belong to either x or y are included in the
 * interval that represents the hull
 *
 * @example
 * ```typescript
 * Interval.hull(
 *   Interval(-1, 1),
 *   Interval(5, 7)
 * )  // Interval(-1, 7)
 * Interval.hull(
 *   Interval(-1, 1),
 *   Interval.EMPTY
 * )  // Interval(-1, 1)
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function hull(x, y) {
    var badX = utils.isEmpty(x);
    var badY = utils.isEmpty(y);
    if (badX && badY) {
        return constants_1.default.EMPTY;
    }
    else if (badX) {
        return y.clone();
    }
    else if (badY) {
        return x.clone();
    }
    else {
        return new interval_1.Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
    }
}
exports.hull = hull;
/**
 * Computes an interval that has all the values that belong to both x and y
 *
 * @example
 * ```typescript
 * Interval.intersection(
 *   Interval(-1, 1),
 *   Interval(0, 7)
 * )  // Interval(0, 1)
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function intersection(x, y) {
    if (utils.isEmpty(x) || utils.isEmpty(y)) {
        return constants_1.default.EMPTY;
    }
    var lo = Math.max(x.lo, y.lo);
    var hi = Math.min(x.hi, y.hi);
    if (lo <= hi) {
        return new interval_1.Interval(lo, hi);
    }
    return constants_1.default.EMPTY;
}
exports.intersection = intersection;
/**
 * Computes an interval that has all the values that belong to both x and y,
 * the difference with {@link hull} is that x and y must overlap to
 * compute the union
 *
 * @example
 * ```typescript
 * Interval.union(
 *   Interval(-1, 1),
 *   Interval(5, 7)
 * )  // throws error
 * Interval.union(
 *   Interval(-1, 1),
 *   Interval(1, 7)
 * )  // Interval(-1, 7)
 * ```
 *
 * @throws {Error} When x and y don't overlap
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function union(x, y) {
    if (!utils.intervalsOverlap(x, y)) {
        throw Error('Interval#union: intervals do not overlap');
    }
    return new interval_1.Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
}
exports.union = union;
/**
 * Computes the difference between `x` and `y`, i.e. an interval with all the
 * values of `x` that are not in `y`
 *
 * @example
 * ```typescript
 * Interval.difference(
 *   Interval(3, 5),
 *   Interval(4, 6)
 * )  // Interval(3, prev(4))
 * Interval.difference(
 *   Interval(0, 3),
 *   Interval(0, 1)
 * )  // Interval(next(1), 3)
 * Interval.difference(
 *   Interval(0, 1),
 *   Interval.WHOLE
 * )  // Interval.EMPTY
 * Interval.difference(
 *   Interval(-Infinity, 0),
 *   Interval.WHOLE
 * )  // Interval.EMPTY
 * ```
 *
 * @throws {Error} When the difference creates multiple intervals
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function difference(x, y) {
    if (utils.isEmpty(x) || utils.isWhole(y)) {
        return constants_1.default.EMPTY;
    }
    if (utils.intervalsOverlap(x, y)) {
        if (x.lo < y.lo && y.hi < x.hi) {
            // difference creates multiple subsets
            throw Error('Interval.difference: difference creates multiple intervals');
        }
        // handle corner cases first
        if ((y.lo <= x.lo && y.hi === Infinity) || (y.hi >= x.hi && y.lo === -Infinity)) {
            return constants_1.default.EMPTY;
        }
        // NOTE: empty interval is handled automatically
        // e.g.
        //
        //    n = difference([0,1], [0,1]) // n = Interval(next(1), 1) = EMPTY
        //    isEmpty(n) === true
        //
        if (y.lo <= x.lo) {
            return new interval_1.Interval().halfOpenLeft(y.hi, x.hi);
        }
        // y.hi >= x.hi
        return new interval_1.Interval().halfOpenRight(x.lo, y.lo);
    }
    return x.clone();
}
exports.difference = difference;
/**
 * Computes the distance between the endpoints of the interval i.e. `x.hi - x.lo`
 *
 * @example
 * ```typescript
 * Interval.width(
 *   Interval(1, 2)
 * )  // 1
 * Interval.width(
 *   Interval(-1, 1)
 * )  // 2
 * Interval.width(
 *   Interval(1, 1)
 * )  // next(0) ~5e-324
 * Interval.width(
 *   Interval.EMPTY
 * )  // 0
 * ```
 *
 * @param {Interval} x
 * @returns {number}
 */
function width(x) {
    if (utils.isEmpty(x)) {
        return 0;
    }
    return round_1.default.subHi(x.hi, x.lo);
}
exports.width = width;
/**
 * Alias for {@link  width}
 * @function
 */
exports.wid = width;
/**
 * Computes the absolute value of `x`
 *
 * @example
 * ```typescript
 * Interval.abs(
 *   Interval(2, 3)
 * )  // Interval(2, 3)
 * Interval.abs(
 *   Interval(-2, 3)
 * )  // Interval(2, 3)
 * Interval.abs(
 *   Interval(-3, -2)
 * )  // Interval(2, 3)
 * Interval.abs(
 *   Interval(-3, 2)
 * )  // Interval(0, 3)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function abs(x) {
    if (utils.isEmpty(x) || utils.isWhole(x)) {
        return constants_1.default.EMPTY;
    }
    if (x.lo >= 0) {
        return x.clone();
    }
    if (x.hi <= 0) {
        return arithmetic.negative(x);
    }
    return new interval_1.Interval(0, Math.max(-x.lo, x.hi));
}
exports.abs = abs;
/**
 * Computes an interval with the maximum values for each endpoint based on `x`
 * and `y`
 *
 * @example
 * ```typescript
 * Interval.max(
 *   Interval(0, 3),
 *   Interval(1, 2)
 * )  // Interval(1, 3)
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function max(x, y) {
    var badX = utils.isEmpty(x);
    var badY = utils.isEmpty(y);
    if (badX && badY) {
        return constants_1.default.EMPTY;
    }
    else if (badX) {
        return y.clone();
    }
    else if (badY) {
        return x.clone();
    }
    else {
        return new interval_1.Interval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));
    }
}
exports.max = max;
/**
 * Computes an interval with the minimum values for each endpoint based on `x` and `y`
 *
 * @example
 * ```typescript
 * Interval.min(
 *   Interval(0, 3),
 *   Interval(1, 2)
 * )  // Interval(0, 2)
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function min(x, y) {
    var badX = utils.isEmpty(x);
    var badY = utils.isEmpty(y);
    if (badX && badY) {
        return constants_1.default.EMPTY;
    }
    else if (badX) {
        return y.clone();
    }
    else if (badY) {
        return x.clone();
    }
    else {
        return new interval_1.Interval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));
    }
}
exports.min = min;
/**
 * Creates an interval equal to `x`, equivalent to `Interval().set(x.lo, x.hi)`
 *
 * @example
 * ```typescript
 * Interval.clone(
 *   Interval(1, 2)
 * )  // Interval(1, 2)
 * Interval.clone(
 *   Interval.EMPTY
 * )  // Interval.EMPTY
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function clone(x) {
    // no bound checking
    return new interval_1.Interval().set(x.lo, x.hi);
}
exports.clone = clone;
//# sourceMappingURL=misc.js.map