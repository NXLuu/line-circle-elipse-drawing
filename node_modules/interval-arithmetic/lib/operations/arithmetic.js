"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var interval_1 = require("../interval");
var round_1 = __importDefault(require("../round"));
var constants_1 = __importDefault(require("../constants"));
var utils = __importStar(require("./utils"));
var division = __importStar(require("./division"));
/**
 * @mixin arithmetic
 */
/**
 * Adds two intervals
 *
 * @example
 * ```typescript
 * Interval.add(
 *   Interval(0, 1),
 *   Interval(1, 2),
 * )   // Interval(prev(1), next(3))
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function add(x, y) {
    return new interval_1.Interval(round_1.default.addLo(x.lo, y.lo), round_1.default.addHi(x.hi, y.hi));
}
exports.add = add;
/**
 * Subtracts two intervals
 *
 * @example
 * ```typescript
 * Interval.subtract(
 *   Interval(0, 1),
 *   Interval(1, 2),
 * )   // Interval(prev(-2), next(0))
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function subtract(x, y) {
    return new interval_1.Interval(round_1.default.subLo(x.lo, y.hi), round_1.default.subHi(x.hi, y.lo));
}
exports.subtract = subtract;
/**
 * Alias for {@link subtract}
 * @function
 */
exports.sub = subtract;
/**
 * Multiplies two intervals, an explanation of all the possible cases ca
 * be found on [Interval Arithmetic: from Principles to Implementation - T. Hickey, Q. Ju, M.H. van Emden](http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf)
 *
 * @example
 * ```typescript
 * Interval.multiply(
 *  Interval(1, 2),
 *  Interval(2, 3)
 * ) // Interval(prev(2), next(6))
 * ```
 *
 * @example
 * ```typescript
 * Interval.multiply(
 *  Interval(1, Infinity),
 *  Interval(4, 6)
 * ) // Interval(prev(4), Infinity)
 * ```
 *
 * @example
 * ```typescript
 * Interval.multiply(
 *  Interval(1, 2),
 *  Interval(-3, -2)
 * ) // Interval(prev(-6), next(-2))
 * ```
 *
 * @example
 * ```typescript
 * Interval.multiply(
 *  Interval(1, 2),
 *  Interval(-2, 3)
 * ) // Interval(prev(-4), next(6))
 * ```
 *
 * @example
 * ```typescript
 * Interval.multiply(
 *  Interval(-2, -1),
 *  Interval(-3, -2)
 * ) // Interval(prev(2), next(6))
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function multiply(x, y) {
    if (utils.isEmpty(x) || utils.isEmpty(y)) {
        return constants_1.default.EMPTY;
    }
    var xl = x.lo;
    var xh = x.hi;
    var yl = y.lo;
    var yh = y.hi;
    var out = new interval_1.Interval();
    if (xl < 0) {
        if (xh > 0) {
            if (yl < 0) {
                if (yh > 0) {
                    // mixed * mixed
                    out.lo = Math.min(round_1.default.mulLo(xl, yh), round_1.default.mulLo(xh, yl));
                    out.hi = Math.max(round_1.default.mulHi(xl, yl), round_1.default.mulHi(xh, yh));
                }
                else {
                    // mixed * negative
                    out.lo = round_1.default.mulLo(xh, yl);
                    out.hi = round_1.default.mulHi(xl, yl);
                }
            }
            else {
                if (yh > 0) {
                    // mixed * positive
                    out.lo = round_1.default.mulLo(xl, yh);
                    out.hi = round_1.default.mulHi(xh, yh);
                }
                else {
                    // mixed * zero
                    out.lo = 0;
                    out.hi = 0;
                }
            }
        }
        else {
            if (yl < 0) {
                if (yh > 0) {
                    // negative * mixed
                    out.lo = round_1.default.mulLo(xl, yh);
                    out.hi = round_1.default.mulHi(xl, yl);
                }
                else {
                    // negative * negative
                    out.lo = round_1.default.mulLo(xh, yh);
                    out.hi = round_1.default.mulHi(xl, yl);
                }
            }
            else {
                if (yh > 0) {
                    // negative * positive
                    out.lo = round_1.default.mulLo(xl, yh);
                    out.hi = round_1.default.mulHi(xh, yl);
                }
                else {
                    // negative * zero
                    out.lo = 0;
                    out.hi = 0;
                }
            }
        }
    }
    else {
        if (xh > 0) {
            if (yl < 0) {
                if (yh > 0) {
                    // positive * mixed
                    out.lo = round_1.default.mulLo(xh, yl);
                    out.hi = round_1.default.mulHi(xh, yh);
                }
                else {
                    // positive * negative
                    out.lo = round_1.default.mulLo(xh, yl);
                    out.hi = round_1.default.mulHi(xl, yh);
                }
            }
            else {
                if (yh > 0) {
                    // positive * positive
                    out.lo = round_1.default.mulLo(xl, yl);
                    out.hi = round_1.default.mulHi(xh, yh);
                }
                else {
                    // positive * zero
                    out.lo = 0;
                    out.hi = 0;
                }
            }
        }
        else {
            // zero * any other value
            out.lo = 0;
            out.hi = 0;
        }
    }
    return out;
}
exports.multiply = multiply;
/**
 * Alias for {@link multiply}
 * @function
 */
exports.mul = multiply;
/**
 * Computes x/y, an explanation of all the possible cases ca
 * be found on [Interval Arithmetic: from Principles to Implementation - T. Hickey, Q. Ju, M.H. van Emden](http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf)
 *
 * NOTE: an extreme case of division might results in multiple
 * intervals, unfortunately this library doesn't support multi-interval
 * arithmetic yet so a single interval will be returned instead with
 * the {@link hull} of the resulting intervals (this is the way
 * Boost implements it too)
 *
 * @example
 * ```typescript
 * Interval.divide(
 *   Interval(1, 2),
 *   Interval(3, 4)
 * ) // Interval(prev(1/4), next(2/3))
 * ```
 *
 * @example
 * ```typescript
 * Interval.divide(
 *   Interval(-2, 1),
 *   Interval(-4, -3)
 * ) // Interval(prev(-1/3), next(2/3))
 * ```
 *
 * @example
 * ```typescript
 * Interval.divide(
 *   Interval(1, 2),
 *   Interval(-1, 1)
 * ) // Interval(-Infinity, Infinity)
 * ```
 *
 * @param {Interval} x
 * @param {Interval} y
 * @return {Interval}
 */
function divide(x, y) {
    if (utils.isEmpty(x) || utils.isEmpty(y)) {
        return constants_1.default.EMPTY;
    }
    if (utils.zeroIn(y)) {
        if (y.lo !== 0) {
            if (y.hi !== 0) {
                return division.zero(x);
            }
            else {
                return division.negative(x, y.lo);
            }
        }
        else {
            if (y.hi !== 0) {
                return division.positive(x, y.hi);
            }
            else {
                return constants_1.default.EMPTY;
            }
        }
    }
    else {
        return division.nonZero(x, y);
    }
}
exports.divide = divide;
/**
 * Alias for {@link divide}
 * @function
 */
exports.div = divide;
/**
 * Computes +x (identity function)
 * @link clone
 *
 * @example
 * ```typescript
 * Interval.positive(
 *  Interval(1, 2)
 * )  // Interval(1, 2)
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function positive(x) {
    return new interval_1.Interval(x.lo, x.hi);
}
exports.positive = positive;
/**
 * Computes -x
 *
 * @example
 * ```typescript
 * Interval.negative(
 *   Interval(1, 2)
 * )  // Interval(-2, -1)
 * ```
 *
 * @example
 * ```typescript
 * Interval.negative(
 *   Interval(-Infinity, Infinity)
 * )  // Interval(-Infinity, Infinity)
 * ```
 *
 * @example
 * ```typescript
 * Interval.negative(
 *   Interval.WHOLE
 * )  // Interval.WHOLE
 * ```
 *
 * @param {Interval} x
 * @return {Interval}
 */
function negative(x) {
    return new interval_1.Interval(-x.hi, -x.lo);
}
exports.negative = negative;
//# sourceMappingURL=arithmetic.js.map